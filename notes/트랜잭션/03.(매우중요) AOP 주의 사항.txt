이 문제를 많은 개발자들이 이해하지 못해서 고통 받는다고 한다.
확실히 이해하도록 하자. 면접에서도 자주 거론되는 문제라고 한다.

"내부 호출"을 하게 되면 프록시를 거치지지 않기 때문에 내부 호출되는 메서드에 트랜잭션이 걸리지 않게 된다.
"9. 스프링 트랜잭션 이해.pdf" 18페이지부터 꼭 읽고 이해하자.

...
...

프록시 방식의 AOP 한계
- @Transactional을 사용하는 트랜잭션 AOP는 프록시를 사용한다. 프록시를 사용하면 메서드 내부 호출에 프록시를 적용할 수 없다.
- 해결 방법은? 가장 단순한 방법은 트랜잭션 적용되어야 하는 메서드를 별도의 클래스로 분리하는 것이다. (그래야 프록시를 거치게 되므로)
- 다른 방법도 있지만 제일 단순하고 합리적인 방법이다. 실무에서도 많이 사용된다고 한다.
- "스프링 핵심원리 고급편 13. 실무 주의사항 - 프록시와 내부 호출 문제"에서 더 다양한 해결 방안이 소개된다.

public 메서드만 트랜잭션 적용
- 스프링의 트랜잭션 AOP 기능은 public 메서드에만 트랜잭션을 적용하도록 기본 설정이 되어 있다.
- protected, private, package-visible 에는 트랜잭션이 적용되지 않는다.
- 트랜잭션은 주로 비즈니스 로직의 시작점에 걸어준다. 이 말은 public 비즈니스 메서드에 트랜잭션이 주로 걸려야 한다는 것이다.
- 그 외의 메서드에 트랜잭션을 적용하게 되면 과도하게 필요 없는 곳까지 트랜잭션이 적용되게 된다.
- public 이 아닌 곳에 @Transactional이 붙어 있으면 예외가 발생하지는 않고, 트랜잭션 적용만 무시된다.


초기화 시점
- 스프링 초기화 시점에는 트랜잭션 AOP가 적용되지 않을 수 있다.
- 초기화 코드(@PostConstruct 같은)가 먼저 호출되고 이후 트랜잭션 AOP가 적용된다.
- 대안
    - @PostConstruct 대신 @EventListener(ApplicationReadyEvent.class) 를 사용하면 된다.
    - 스프링 어플리케이션 로드가 끝난 후에 해당 메서드를 실행하게 된다. 즉 이 시점에는 트랜잭션 AOP가 이미 완성되어 있기 때문에 트랜잭션을 잘 걸게 된다.
    - initTxTest 테스트 클래스 참조
- 결론: 트랜잭션 내에서 무엇인가 초기화 코드를 수행해야 한다면 @PostConstruct 대신 @EventListener(ApplicationReadyEvent.class) 를 사용하면 된다.
